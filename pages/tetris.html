<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Autoplay Tetris</title>
    <style>
        :root {
            --bg: #000;
            --fg: #00ff00;
            --fg-dim: #009900;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            color: var(--fg);
            font-family: monospace;
            cursor: none;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            pointer-events: none;
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
            gap: 8px;
        }

        canvas {
            background: #000;
            box-shadow: 0 0 32px rgba(0, 255, 0, 0.2);
            image-rendering: pixelated;
        }

        #next {
            font-size: 12px;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="hud">F0RTHSP4CE · VERTICAL TETRIS · AUTOPLAY</div>
    <div id="game-wrapper">
        <canvas id="game" width="320" height="640"></canvas>
        <div id="next">next: <span id="next-piece"></span></div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 22; // includes hidden buffer rows at top
        const VISIBLE_ROWS = 20;
        const DROP_INTERVAL = 80; // ms per drop step

        const SHAPES = {
            I: [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
            ],
            J: [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0],
            ],
            L: [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0],
            ],
            O: [
                [1, 1],
                [1, 1],
            ],
            S: [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0],
            ],
            T: [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0],
            ],
            Z: [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0],
            ],
        };

        const PIECES = Object.keys(SHAPES);

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const nextSpan = document.getElementById("next-piece");

        let block = 24;

        const state = {
            board: createBoard(),
            current: null,
            pos: { x: 0, y: 0 },
            next: randomPiece(),
            plan: null,
            lastDrop: performance.now(),
            lines: 0,
            gameOver: false,
        };

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function randomPiece() {
            const key = PIECES[Math.floor(Math.random() * PIECES.length)];
            return { key, shape: SHAPES[key].map(row => [...row]) };
        }

        function rotate(shape) {
            const h = shape.length;
            const w = shape[0].length;
            const res = Array.from({ length: w }, () => Array(h).fill(0));
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    res[x][h - 1 - y] = shape[y][x];
                }
            }
            return res;
        }

        function cloneBoard(board) {
            return board.map(row => [...row]);
        }

        function collides(shape, pos, board) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (!shape[y][x]) continue;
                    const bx = pos.x + x;
                    const by = pos.y + y;
                    if (bx < 0 || bx >= COLS || by >= ROWS) return true;
                    if (by >= 0 && board[by][bx]) return true;
                }
            }
            return false;
        }

        function merge(board, shape, pos) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (!shape[y][x]) continue;
                    const bx = pos.x + x;
                    const by = pos.y + y;
                    if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) {
                        board[by][bx] = 1;
                    }
                }
            }
        }

        function clearLines(board) {
            let cleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    cleared++;
                    y++;
                }
            }
            return cleared;
        }

        function boardMetrics(board) {
            const heights = Array(COLS).fill(0);
            const holes = Array(COLS).fill(0);
            const wellDepths = Array(COLS).fill(0);
            for (let x = 0; x < COLS; x++) {
                let blockSeen = false;
                for (let y = 0; y < ROWS; y++) {
                    if (board[y][x]) {
                        blockSeen = true;
                        if (!heights[x]) heights[x] = ROWS - y;
                    } else if (blockSeen) {
                        holes[x]++;
                    }
                }
            }

            for (let x = 0; x < COLS; x++) {
                let depth = 0;
                for (let y = 0; y < ROWS; y++) {
                    const left = x === 0 ? 1 : board[y][x - 1];
                    const right = x === COLS - 1 ? 1 : board[y][x + 1];
                    if (!board[y][x] && left && right) {
                        depth++;
                        wellDepths[x] += depth;
                    } else {
                        depth = 0;
                    }
                }
            }

            let bumpiness = 0;
            for (let x = 0; x < COLS - 1; x++) {
                bumpiness += Math.abs(heights[x] - heights[x + 1]);
            }

            const aggregateHeight = heights.reduce((a, b) => a + b, 0);
            const totalHoles = holes.reduce((a, b) => a + b, 0);
            const wells = wellDepths.reduce((a, b) => a + b, 0);
            return { aggregateHeight, totalHoles, bumpiness, wells };
        }

        function evaluateBoard(board, linesCleared) {
            const { aggregateHeight, totalHoles, bumpiness, wells } = boardMetrics(board);
            // Tuned for "keep it low" behavior.
            return (
                linesCleared * 10 -
                aggregateHeight * 0.45 -
                totalHoles * 5 -
                bumpiness * 0.35 -
                wells * 0.08
            );
        }

        function placements(piece, board) {
            const results = [];
            let shape = piece.shape;
            for (let r = 0; r < 4; r++) {
                const width = shape[0].length;
                const minX = 0;
                const maxX = COLS - width;
                for (let x = minX; x <= maxX; x++) {
                    let y = -2; // start slightly above visible board
                    while (!collides(shape, { x, y: y + 1 }, board)) {
                        y++;
                    }
                    const boardCopy = cloneBoard(board);
                    merge(boardCopy, shape, { x, y });
                    const linesCleared = clearLines(boardCopy);
                    const score = evaluateBoard(boardCopy, linesCleared);
                    results.push({ score, x, shape: shape.map(row => [...row]), linesCleared });
                }
                shape = rotate(shape);
            }
            results.sort((a, b) => b.score - a.score);
            return results;
        }

        function pickPlan() {
            const options = placements(state.current, state.board);
            return options[0] || null;
        }

        function spawnPiece() {
            state.current = state.next;
            state.next = randomPiece();
            nextSpan.textContent = state.next.key;
            state.pos = { x: Math.floor((COLS - state.current.shape[0].length) / 2), y: -2 };
            state.plan = pickPlan();
            if (collides(state.current.shape, state.pos, state.board)) {
                state.board = createBoard();
                state.lines = 0;
            }
        }

        function stepAutoplay() {
            if (!state.plan) return;
            // Snap rotation/column immediately for simplicity.
            state.current.shape = state.plan.shape;
            state.pos.x = state.plan.x;
        }

        function drop() {
            if (collides(state.current.shape, { x: state.pos.x, y: state.pos.y + 1 }, state.board)) {
                merge(state.board, state.current.shape, state.pos);
                const cleared = clearLines(state.board);
                state.lines += cleared;
                spawnPiece();
            } else {
                state.pos.y += 1;
            }
        }

        function resize() {
            const usableHeight = window.innerHeight;
            const usableWidth = window.innerWidth;
            // Fit to the limiting dimension while keeping 10x20 aspect.
            const blockSize = Math.floor(Math.min(usableWidth / COLS, usableHeight / VISIBLE_ROWS));
            block = Math.max(12, blockSize);
            canvas.width = block * COLS;
            canvas.height = block * VISIBLE_ROWS;
        }

        function drawBlock(x, y, dim) {
            ctx.fillStyle = "#003300";
            ctx.fillRect(x * block, y * block, block, block);
            ctx.fillStyle = varColor(dim);
            ctx.fillRect(x * block + 2, y * block + 2, block - 4, block - 4);
        }

        function varColor(dim) {
            return dim ? "#007700" : "#00ff00";
        }

        function render() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid (subtle)
            ctx.strokeStyle = "#003300";
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * block + 0.5, 0);
                ctx.lineTo(x * block + 0.5, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= VISIBLE_ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * block + 0.5);
                ctx.lineTo(canvas.width, y * block + 0.5);
                ctx.stroke();
            }

            for (let y = 0; y < VISIBLE_ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (state.board[y + (ROWS - VISIBLE_ROWS)][x]) {
                        drawBlock(x, y, true);
                    }
                }
            }

            for (let y = 0; y < state.current.shape.length; y++) {
                for (let x = 0; x < state.current.shape[y].length; x++) {
                    if (!state.current.shape[y][x]) continue;
                    const drawY = state.pos.y + y - (ROWS - VISIBLE_ROWS);
                    if (drawY >= 0) drawBlock(state.pos.x + x, drawY, false);
                }
            }
        }

        function loop(now) {
            const delta = now - state.lastDrop;
            if (delta > DROP_INTERVAL) {
                state.lastDrop = now;
                stepAutoplay();
                drop();
            }
            render();
            requestAnimationFrame(loop);
        }

        resize();
        spawnPiece();
        window.addEventListener("resize", resize);
        requestAnimationFrame(loop);
    </script>
</body>
</html>
